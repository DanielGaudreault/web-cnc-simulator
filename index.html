<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebCNC Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1e1e1e;
            color: #fff;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: 60px 1fr 200px;
            height: 100vh;
            gap: 1px;
            background: #333;
        }

        .header {
            grid-column: 1 / -1;
            background: #2d2d2d;
            display: flex;
            align-items: center;
            padding: 0 20px;
            border-bottom: 1px solid #444;
        }

        .logo {
            font-size: 1.5em;
            font-weight: bold;
            color: #4CAF50;
        }

        .sidebar {
            background: #252526;
            padding: 15px;
            overflow-y: auto;
        }

        .viewer {
            background: #1e1e1e;
            position: relative;
        }

        .tools-panel {
            background: #252526;
            padding: 15px;
            overflow-y: auto;
        }

        .gcode-panel {
            grid-column: 1 / -1;
            background: #1e1e1e;
            display: flex;
            flex-direction: column;
        }

        .panel-header {
            background: #2d2d2d;
            padding: 10px 15px;
            font-weight: bold;
            border-bottom: 1px solid #444;
        }

        .gcode-editor {
            flex: 1;
            background: #1e1e1e;
            color: #d4d4d4;
            border: none;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9em;
            color: #ccc;
        }

        input, select, button {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #fff;
            border-radius: 3px;
        }

        button {
            background: #4CAF50;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }

        button:hover {
            background: #45a049;
        }

        .tool-button {
            background: #2196F3;
            margin: 2px;
        }

        .control-buttons {
            display: flex;
            gap: 5px;
        }

        .control-buttons button {
            flex: 1;
        }

        #viewport {
            width: 100%;
            height: 100%;
            display: block;
        }

        .coordinates {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 3px;
            font-family: monospace;
        }

        .simulation-info {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px 12px;
            border-radius: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="logo">WebCNC Simulator</div>
        </div>

        <div class="sidebar">
            <div class="control-group">
                <div class="control-label">Workpiece Setup</div>
                <input type="number" id="workpieceWidth" placeholder="Width (mm)" value="100">
                <input type="number" id="workpieceHeight" placeholder="Height (mm)" value="100">
                <input type="number" id="workpieceDepth" placeholder="Depth (mm)" value="20">
                <button onclick="createWorkpiece()">Create Workpiece</button>
            </div>

            <div class="control-group">
                <div class="control-label">Tool Setup</div>
                <select id="toolType">
                    <option value="endmill">End Mill (6mm)</option>
                    <option value="ballnose">Ball Nose (8mm)</option>
                    <option value="drill">Drill (4mm)</option>
                </select>
                <input type="number" id="toolDiameter" placeholder="Tool Diameter (mm)" value="6">
                <input type="number" id="feedRate" placeholder="Feed Rate (mm/min)" value="1000">
            </div>

            <div class="control-group">
                <div class="control-label">Simulation Controls</div>
                <div class="control-buttons">
                    <button onclick="startSimulation()" style="background:#4CAF50">▶ Play</button>
                    <button onclick="pauseSimulation()" style="background:#ff9800">⏸ Pause</button>
                    <button onclick="resetSimulation()" style="background:#f44336">⏹ Stop</button>
                </div>
                <input type="range" id="simulationSpeed" min="1" max="10" value="5">
                <div class="control-label">Speed: <span id="speedValue">5</span>x</div>
            </div>
        </div>

        <div class="viewer">
            <canvas id="viewport"></canvas>
            <div class="coordinates" id="coordinates">X: 0.00 Y: 0.00 Z: 0.00</div>
            <div class="simulation-info" id="simulationInfo">Ready</div>
        </div>

        <div class="tools-panel">
            <div class="control-group">
                <div class="control-label">Quick G-code</div>
                <button class="tool-button" onclick="generateSquarePocket()">Square Pocket</button>
                <button class="tool-button" onclick="generateCircle()">Circle</button>
                <button class="tool-button" onclick="generateGrid()">Grid Pattern</button>
                <button class="tool-button" onclick="generateSpiral()">Spiral</button>
            </div>

            <div class="control-group">
                <div class="control-label">Visualization</div>
                <button class="tool-button" onclick="toggleToolpath()">Toggle Toolpath</button>
                <button class="tool-button" onclick="toggleWorkpiece()">Toggle Workpiece</button>
                <button class="tool-button" onclick="resetView()">Reset View</button>
            </div>

            <div class="control-group">
                <div class="control-label">Simulation Stats</div>
                <div id="stats">
                    <div>Time: 0:00</div>
                    <div>Operations: 0</div>
                    <div>Material Removed: 0%</div>
                </div>
            </div>
        </div>

        <div class="gcode-panel">
            <div class="panel-header">G-code Editor</div>
            <textarea class="gcode-editor" id="gcodeEditor" spellcheck="false">
G21 ; Millimeter units
G90 ; Absolute positioning
G17 ; XY plane selection

; Square Pocket Example
G0 Z5
G0 X20 Y20
G1 Z-2 F500
G1 X80 F1000
G1 Y80
G1 X20
G1 Y20
G0 Z5

; Circle Example
G0 X50 Y50
G1 Z-1 F500
G2 X50 Y50 I10 J0 F800
G0 Z5

M30 ; Program end
            </textarea>
        </div>
    </div>

    <script>
        // Three.js CNC Simulator - Entirely Client Side
        class CNCSimulator {
            constructor() {
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.workpiece = null;
                this.tool = null;
                this.toolPath = null;
                this.isSimulating = false;
                this.simulationSpeed = 5;
                this.currentCommandIndex = 0;
                this.gcodeCommands = [];
                this.currentPosition = { x: 0, y: 0, z: 0 };
                
                this.init();
            }

            init() {
                this.setupScene();
                this.createWorkpiece(100, 100, 20);
                this.createTool();
                this.setupEventListeners();
                this.animate();
            }

            setupScene() {
                const canvas = document.getElementById('viewport');
                
                // Scene
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1e1e1e);

                // Camera
                this.camera = new THREE.PerspectiveCamera(75, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
                this.camera.position.set(150, 150, 150);
                this.camera.lookAt(0, 0, 0);

                // Renderer
                this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                this.renderer.shadowMap.enabled = true;

                // Lighting
                const ambientLight = new THREE.AmbientLight(0x404040);
                this.scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
                directionalLight.position.set(50, 50, 50);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);

                // Grid Helper
                const gridHelper = new THREE.GridHelper(200, 20, 0x444444, 0x222222);
                this.scene.add(gridHelper);

                // Axes Helper
                const axesHelper = new THREE.AxesHelper(50);
                this.scene.add(axesHelper);
            }

            createWorkpiece(width = 100, height = 100, depth = 20) {
                if (this.workpiece) {
                    this.scene.remove(this.workpiece);
                }

                const geometry = new THREE.BoxGeometry(width, height, depth);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x888888,
                    transparent: true,
                    opacity: 0.8
                });
                
                this.workpiece = new THREE.Mesh(geometry, material);
                this.workpiece.position.y = depth / 2; // Sit on grid
                this.scene.add(this.workpiece);

                this.workpiece.userData = {
                    originalGeometry: geometry.clone(),
                    materialRemoved: false
                };
            }

            createTool() {
                if (this.tool) {
                    this.scene.remove(this.tool);
                }

                const toolGeometry = new THREE.CylinderGeometry(3, 3, 20, 16);
                const toolMaterial = new THREE.MeshBasicMaterial({ color: 0xff4444 });
                this.tool = new THREE.Mesh(toolGeometry, toolMaterial);
                this.tool.visible = false;
                this.scene.add(this.tool);
            }

            parseGCode(gcode) {
                this.gcodeCommands = [];
                const lines = gcode.split('\n');
                
                lines.forEach(line => {
                    const command = this.parseLine(line.trim());
                    if (command) {
                        this.gcodeCommands.push(command);
                    }
                });
                
                this.visualizeToolpath();
                return this.gcodeCommands;
            }

            parseLine(line) {
                if (!line || line.startsWith(';')) return null;

                // Simple G-code parser
                const parts = line.split(';')[0].trim().split(/\s+/);
                if (parts.length === 0) return null;

                const command = { type: 'unknown', parameters: {} };

                parts.forEach(part => {
                    const code = part[0].toUpperCase();
                    const value = parseFloat(part.substring(1));

                    if (code === 'G' || code === 'M') {
                        command.type = code + value;
                    } else if ('XYZFIJKR'.includes(code)) {
                        command.parameters[code] = value;
                    }
                });

                return command;
            }

            visualizeToolpath() {
                if (this.toolPath) {
                    this.scene.remove(this.toolPath);
                }

                const points = [];
                let currentPos = { x: 0, y: 0, z: 0 };

                this.gcodeCommands.forEach(cmd => {
                    if (cmd.type === 'G0' || cmd.type === 'G1') {
                        const newPos = {
                            x: cmd.parameters.X !== undefined ? cmd.parameters.X : currentPos.x,
                            y: cmd.parameters.Y !== undefined ? cmd.parameters.Y : currentPos.y,
                            z: cmd.parameters.Z !== undefined ? cmd.parameters.Z : currentPos.z
                        };
                        
                        points.push(new THREE.Vector3(currentPos.x, currentPos.z, currentPos.y));
                        points.push(new THREE.Vector3(newPos.x, newPos.z, newPos.y));
                        
                        currentPos = { ...newPos };
                    }
                });

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00ff00 });
                this.toolPath = new THREE.LineSegments(geometry, material);
                this.scene.add(this.toolPath);
            }

            async startSimulation() {
                if (this.isSimulating) return;
                
                this.isSimulating = true;
                this.currentCommandIndex = 0;
                this.currentPosition = { x: 0, y: 0, z: 0 };
                this.tool.visible = true;

                const gcode = document.getElementById('gcodeEditor').value;
                this.parseGCode(gcode);

                while (this.isSimulating && this.currentCommandIndex < this.gcodeCommands.length) {
                    await this.executeCommand(this.gcodeCommands[this.currentCommandIndex]);
                    this.currentCommandIndex++;
                    
                    // Add delay for visualization
                    await new Promise(resolve => 
                        setTimeout(resolve, 100 / this.simulationSpeed)
                    );
                }

                this.isSimulating = false;
                this.tool.visible = false;
                document.getElementById('simulationInfo').textContent = 'Simulation Complete';
            }

            async executeCommand(command) {
                document.getElementById('simulationInfo').textContent = 
                    `Executing: ${command.type}`;

                switch (command.type) {
                    case 'G0': // Rapid move
                    case 'G1': // Linear move
                        await this.moveTool(command);
                        break;
                    case 'G2': // Circular move CW
                    case 'G3': // Circular move CCW
                        await this.circularMove(command);
                        break;
                    case 'G17': // XY plane selection
                    case 'G21': // Millimeter units
                    case 'G90': // Absolute positioning
                        // These are handled by state, just continue
                        break;
                    case 'M30': // Program end
                        this.isSimulating = false;
                        break;
                }

                this.updateCoordinates();
            }

            async moveTool(command) {
                const target = {
                    x: command.parameters.X !== undefined ? command.parameters.X : this.currentPosition.x,
                    y: command.parameters.Y !== undefined ? command.parameters.Y : this.currentPosition.y,
                    z: command.parameters.Z !== undefined ? command.parameters.Z : this.currentPosition.z
                };

                const steps = 20;
                for (let i = 0; i <= steps; i++) {
                    if (!this.isSimulating) break;
                    
                    const t = i / steps;
                    this.currentPosition.x = this.lerp(this.currentPosition.x, target.x, t);
                    this.currentPosition.y = this.lerp(this.currentPosition.y, target.y, t);
                    this.currentPosition.z = this.lerp(this.currentPosition.z, target.z, t);
                    
                    this.tool.position.set(
                        this.currentPosition.x,
                        this.currentPosition.z + 10, // Tool height offset
                        this.currentPosition.y
                    );

                    // Simulate material removal for cutting moves
                    if (command.type === 'G1' && this.currentPosition.z < 0) {
                        this.simulateMaterialRemoval();
                    }

                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }

            async circularMove(command) {
                // Simplified circular interpolation
                const center = {
                    x: this.currentPosition.x + (command.parameters.I || 0),
                    y: this.currentPosition.y + (command.parameters.J || 0)
                };
                
                const radius = Math.sqrt(
                    Math.pow(command.parameters.I || 0, 2) + 
                    Math.pow(command.parameters.J || 0, 2)
                );

                const startAngle = Math.atan2(
                    this.currentPosition.y - center.y,
                    this.currentPosition.x - center.x
                );

                const endAngle = startAngle + (command.type === 'G2' ? -Math.PI * 2 : Math.PI * 2);
                const steps = 36;

                for (let i = 0; i <= steps; i++) {
                    if (!this.isSimulating) break;
                    
                    const angle = this.lerp(startAngle, endAngle, i / steps);
                    this.currentPosition.x = center.x + Math.cos(angle) * radius;
                    this.currentPosition.y = center.y + Math.sin(angle) * radius;
                    
                    this.tool.position.set(
                        this.currentPosition.x,
                        this.currentPosition.z + 10,
                        this.currentPosition.y
                    );

                    if (this.currentPosition.z < 0) {
                        this.simulateMaterialRemoval();
                    }

                    await new Promise(resolve => setTimeout(resolve, 20));
                }
            }

            simulateMaterialRemoval() {
                // Simple material removal visualization
                if (this.workpiece.userData.materialRemoved) return;
                
                this.workpiece.material.opacity = 0.6;
                this.workpiece.material.color.setHex(0x666666);
                this.workpiece.userData.materialRemoved = true;
            }

            lerp(start, end, factor) {
                return start + (end - start) * factor;
            }

            updateCoordinates() {
                const coords = document.getElementById('coordinates');
                coords.textContent = 
                    `X: ${this.currentPosition.x.toFixed(2)} Y: ${this.currentPosition.y.toFixed(2)} Z: ${this.currentPosition.z.toFixed(2)}`;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.onWindowResize());
                
                // Simulation speed control
                document.getElementById('simulationSpeed').addEventListener('input', (e) => {
                    this.simulationSpeed = e.target.value;
                    document.getElementById('speedValue').textContent = e.target.value;
                });
            }

            onWindowResize() {
                const canvas = document.getElementById('viewport');
                this.camera.aspect = canvas.clientWidth / canvas.clientHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.renderer.render(this.scene, this.camera);
            }

            pauseSimulation() {
                this.isSimulating = false;
            }

            resetSimulation() {
                this.isSimulating = false;
                this.currentCommandIndex = 0;
                this.currentPosition = { x: 0, y: 0, z: 0 };
                this.tool.visible = false;
                
                // Reset workpiece
                if (this.workpiece) {
                    this.workpiece.material.opacity = 0.8;
                    this.workpiece.material.color.setHex(0x888888);
                    this.workpiece.userData.materialRemoved = false;
                }
                
                document.getElementById('simulationInfo').textContent = 'Ready';
                this.updateCoordinates();
            }
        }

        // Global simulator instance
        let simulator;

        // Initialize when page loads
        window.addEventListener('DOMContentLoaded', () => {
            // Load Three.js from CDN
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
            script.onload = () => {
                simulator = new CNCSimulator();
            };
            document.head.appendChild(script);
        });

        // UI Control Functions
        function createWorkpiece() {
            const width = parseFloat(document.getElementById('workpieceWidth').value) || 100;
            const height = parseFloat(document.getElementById('workpieceHeight').value) || 100;
            const depth = parseFloat(document.getElementById('workpieceDepth').value) || 20;
            
            if (simulator) {
                simulator.createWorkpiece(width, height, depth);
            }
        }

        function startSimulation() {
            if (simulator) {
                simulator.startSimulation();
            }
        }

        function pauseSimulation() {
            if (simulator) {
                simulator.pauseSimulation();
            }
        }

        function resetSimulation() {
            if (simulator) {
                simulator.resetSimulation();
            }
        }

        function toggleToolpath() {
            if (simulator && simulator.toolPath) {
                simulator.toolPath.visible = !simulator.toolPath.visible;
            }
        }

        function toggleWorkpiece() {
            if (simulator && simulator.workpiece) {
                simulator.workpiece.visible = !simulator.workpiece.visible;
            }
        }

        function resetView() {
            if (simulator && simulator.camera) {
                simulator.camera.position.set(150, 150, 150);
                simulator.camera.lookAt(0, 0, 0);
            }
        }

        // Example G-code generators
        function generateSquarePocket() {
            const gcode = `G21
G90
G17

; Square Pocket
G0 Z5
G0 X25 Y25
G1 Z-3 F500
G1 X75 F1000
G1 Y75
G1 X25
G1 Y25
G0 Z5

M30`;
            document.getElementById('gcodeEditor').value = gcode;
        }

        function generateCircle() {
            const gcode = `G21
G90
G17

; Circle
G0 Z5
G0 X50 Y50
G1 Z-2 F500
G2 X50 Y50 I15 J0 F800
G0 Z5

M30`;
            document.getElementById('gcodeEditor').value = gcode;
        }

        function generateGrid() {
            const gcode = `G21
G90
G17

; Grid Pattern
G0 Z5
G1 Z-1 F500

; Horizontal lines
G0 X20 Y20
G1 X80 F1000
G0 X20 Y40
G1 X80
G0 X20 Y60
G1 X80
G0 X20 Y80
G1 X80

; Vertical lines
G0 X20 Y20
G1 Y80
G0 X40 Y20
G1 Y80
G0 X60 Y20
G1 Y80
G0 X80 Y20
G1 Y80

G0 Z5
M30`;
            document.getElementById('gcodeEditor').value = gcode;
        }

        function generateSpiral() {
            const gcode = `G21
G90
G17

; Spiral
G0 Z5
G0 X50 Y50
G1 Z-2 F500

; Spiral outwards
G2 X50 Y50 I1 J0 F800
G2 X50 Y50 I2 J0
G2 X50 Y50 I3 J0
G2 X50 Y50 I4 J0
G2 X50 Y50 I5 J0
G2 X50 Y50 I6 J0
G2 X50 Y50 I7 J0
G2 X50 Y50 I8 J0
G2 X50 Y50 I9 J0
G2 X50 Y50 I10 J0

G0 Z5
M30`;
            document.getElementById('gcodeEditor').value = gcode;
        }
    </script>
</body>
</html>
